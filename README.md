1.两数之和  
  给定 nums = [2, 7, 11, 15], target = 9  
  nums[0] + nums[1] = 2 + 7 = 9  
  返回 [0,1]  
  解法：使用unordered_map来保存所淘汰元素，然后使用find算法快速匹配  

2.两数相加  
  给出两个“非空”的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储1个数字。  
  如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。  
  输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)  
  输出：7 -> 0 -> 8  
  原因：342 + 465 = 807  
  解法：使用了链表的定义 val、next；然后定义一个标志变量来添加进位  
  
3.圆圈中剩下的数  
  0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。  
  例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。  
  解法：使用逆推，最后一个元素的位置一定是0，每次删除的元素是 m%n--  
  
4.无重复字符的最长子串  
  给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。  
  解法：窗口滑动；使用一个vector装界定元素，定义两个标志元素，一个在遍历子串，一个用来保存不重复的界限  
  
5.给定一个字符串 s，找到 s 中最长的回文子串。  
  输入: "babad"   输出: "bab"  
  解法：中心扩展法，分开一个中心和两个中心  
  
6.判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  
  解法：第一种可以颠倒数字，第二种转换为字符串操作  

7.将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。  
  输入: s = "LEETCODEISHIRING", numRows = 3  
  输出: "LCIRETOESIIGEDHN"  
  解法：建立与行数相等的装字符的容器数（小心字符数小于行数），再添加一个标志符来转头，在0和n-1处  
  
8.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。  
  假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  
  解法：留意溢出，数字反转
