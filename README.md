1.两数之和  
  给定 nums = [2, 7, 11, 15], target = 9  
  nums[0] + nums[1] = 2 + 7 = 9  
  返回 [0,1]  
  解法：使用unordered_map来保存所淘汰元素，然后使用find算法快速匹配  

2.两数相加  
  给出两个“非空”的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储1个数字。  
  如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。  
  输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)  
  输出：7 -> 0 -> 8  
  原因：342 + 465 = 807  
  解法：使用了链表的定义 val、next；然后定义一个标志变量来添加进位  
  
3.圆圈中剩下的数  
  0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。  
  例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。  
  解法：使用逆推，最后一个元素的位置一定是0，每次删除的元素是 m%n--  
  
4.无重复字符的最长子串  
  给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。  
  解法：窗口滑动；使用一个vector装界定元素，定义两个标志元素，一个在遍历子串，一个用来保存不重复的界限  
  
5.给定一个字符串 s，找到 s 中最长的回文子串。  
  输入: "babad"   输出: "bab"  
  解法：中心扩展法，分开一个中心和两个中心  
  
6.判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  
  解法：第一种可以颠倒数字，第二种转换为字符串操作  

7.将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。  
  输入: s = "LEETCODEISHIRING", numRows = 3  
  输出: "LCIRETOESIIGEDHN"  
  解法：建立与行数相等的装字符的容器数（小心字符数小于行数），再添加一个标志符来转头，在0和n-1处  
  
8.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。  
  假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  
  解法：留意溢出，数字反转

9.请你来实现一个 atoi 函数，使其能将字符串转换成整数。  
  首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。  
  当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将     与之后连续的数字字符组合起来，形成整数。  
10.给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出   其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。  
  解法：双指针
  
11.给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。  
  罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。  
  int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};  
  string reps[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};  
  解法：贪心算法   
  
12.编写一个函数来查找字符串数组中的最长公共前缀。  
  如果不存在公共前缀，返回空字符串 ""。  
  输入: ["flower","flow","flight"]  
  输出: "fl"  
  解法：双指针法  
  
13.给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
  注意：答案中不可以包含重复的三元组。
  解法：双指针法，重点是去重
